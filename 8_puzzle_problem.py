# -*- coding: utf-8 -*-
"""8 Puzzle Problem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ukI2hUQn0XJ5724fLviJFkpHiyfdIIWO
"""

import random
import copy 
import heapdict

# Start state of board is determined randomly
lst = [0, 1, 2, 3, 4, 5, 6, 7, 8]
newList = random.sample(lst, 9)
board = [[newList[0], newList[1], newList[2]], [newList[3], newList[4], newList[5]], [newList[6], newList[7], newList[8]]]

# The start state of the board is printed
print("Starting board: ")
print("")
print(board[0])
print(board[1])
print(board[2])
print("----------------")

# The final state we are trying to achieve
goalBoard = [[1, 2, 3], [8, 0, 4], [7, 6, 5]]

# Returns the current position of the blank space
# Takes the board as input parameter

def getEmpty(board):
  blankPos = [0, 0] # Create variable to store blank spot's position
  i = 0 # row number
  j = 0 # column number

  # Nested loop to iterate through each value of each row
  # Outer loop = rows
  # Inner loop = columns
  while i < 3:
    j = 0 
    while j < 3:
      if board[i][j] == 0: # Checks board values for the blank space
        blankPos[0] = i # Row blank space is in
        blankPos[1] = j # Column blank space is in
        return blankPos
      j = j + 1 # Move onto next column
    i = i + 1 # Move onto next row

blankPos = getEmpty(board) # Getting the start state's blank position

# Class to store the nodes, their values, and their children nodes
# Each child represents one of the next possible moves
# Four children because a state can have at most four possible moves
class Node:
  def __init__(self, data):
    self.level = 0 # level within the tree that the node is present at
    self.data = data # The 2d list representation of the board
    self.child1 = None # The next state achieved if next move = UP
    self.child2 = None # The next state achieved if next move = DOWN
    self.child3 = None # The next state achieved if next move = LEFT
    self.child4 = None # The next state achieved if next move = RIGHT
    self.parent = None # The node's parent
  
  # Add child1 to the node
  def add_child1(self, child):
    child.parent = self
    self.child1 = child
  
  # Add child2 to the node
  def add_child2(self, child):
    child.parent = self
    self.child2 = child
  
  # Add child3 to the node
  def add_child3(self, child):
    child.parent = self
    self.child3 = child
  
  # Add child4 to the node
  def add_child4(self, child):
    child.parent = self
    self.child4 = child

root = Node(board) # The node that holds the board's starting state

# Class that builds the tree
# Input parameters = current node, previous blank space, current level of tree
# Level of tree begins at starting level (Level 0)
def buildTree(node, previousBlank, levelNumber = 0):
  maxLevels = 15 # The maximum depth of the tree 

  if node != None: # Checks to make sure node is not empty
    newBoard = node.data # board to store future states
    
    # Four boards are created to store up to four possible next moves
    newBoard1 = copy.deepcopy(newBoard)
    newBoard2 = copy.deepcopy(newBoard)
    newBoard3 = copy.deepcopy(newBoard)
    newBoard4 = copy.deepcopy(newBoard)

    # Four variables to store the level of the tree that children are in
    levelNumber1 = levelNumber
    levelNumber2 = levelNumber
    levelNumber3 = levelNumber
    levelNumber4 = levelNumber

    blankPos = getEmpty(newBoard) # Current blank position is obtained

    if blankPos[0] - 1 > -1: # Checks to make sure blank position doesn't go off the top edge of the board
      neighborVal = newBoard1[blankPos[0] - 1][blankPos[1]] # Gets value of space above the blank space
      neighborPos = [blankPos[0] - 1, blankPos[1]] # Gets the position of the value above the blank space

      if neighborPos != previousBlank: # Checks if neighbor position is not position we just came from
        newBoard1[blankPos[0] - 1][blankPos[1]] = 0 # Swaps blank space with neighbor
        newBoard1[blankPos[0]][blankPos[1]] = neighborVal # Neighbor's value goes to former blank space
        node.add_child1(Node(newBoard1)) # New board configuration is added as a child node
        
        if levelNumber1 <= maxLevels: # Checks if bottom level has been reached
          levelNumber1 = levelNumber1 + 1 # child's level value is updated
          node.child1.level = levelNumber1
          buildTree(node.child1, blankPos, levelNumber1) # child1 is added to node

    
    if blankPos[0] + 1 < 3: # Checks to make sure blank position doesn't go off the bottom edge of the board
      neighborVal = newBoard2[blankPos[0] + 1][blankPos[1]] # Gets value of space below the blank space
      neighborPos = [blankPos[0] + 1, blankPos[1]] # Gets the position of the value below the blank space

      if neighborPos != previousBlank: # Checks if neighbor position is not position we just came from
        newBoard2[blankPos[0] + 1][blankPos[1]] = 0 # Swaps blank space with neighbor
        newBoard2[blankPos[0]][blankPos[1]] = neighborVal # Neighbor's value goes to former blank space
        node.add_child2(Node(newBoard2)) # New board configuration is added as a child node

        if levelNumber2 <= maxLevels: # Checks if bottom level has been reached
          levelNumber2 = levelNumber2 + 1 # child's level value is updated
          node.child2.level = levelNumber2
          buildTree(node.child2, blankPos, levelNumber2) # child2 is added to node

      
    if blankPos[1] - 1 > -1: # Checks to make sure blank position doesn't go off the left edge of the board
      neighborVal = newBoard3[blankPos[0]][blankPos[1] - 1] # Gets value of space left of the blank space
      neighborPos = [blankPos[0], blankPos[1] - 1] # Gets the position of the value left of the blank space

      if neighborPos != previousBlank: # Checks if neighbor position is not position we just came from
        newBoard3[blankPos[0]][blankPos[1] - 1] = 0 # Swaps blank space with neighbor
        newBoard3[blankPos[0]][blankPos[1]] = neighborVal # Neighbor's value goes to former blank space
        node.add_child3(Node(newBoard3)) # New board configuration is added as a child node

        if levelNumber3 <= maxLevels: # Checks if bottom level has been reached
          levelNumber3 = levelNumber3 + 1 # child's level value is updated
          node.child3.level = levelNumber3
          buildTree(node.child3, blankPos, levelNumber3) # child3 is added to node


    if blankPos[1] + 1 < 3: # Checks to make sure blank position doesn't go off the right edge of the board
      neighborVal = newBoard4[blankPos[0]][blankPos[1] + 1] # Gets value of space right of the blank space
      neighborPos = [blankPos[0], blankPos[1] + 1] # Gets the position of the value right of the blank space

      if neighborPos != previousBlank: # Checks if neighbor position is not position we just came from
        newBoard4[blankPos[0]][blankPos[1] + 1] = 0 # Swaps blank space with neighbor
        newBoard4[blankPos[0]][blankPos[1]] = neighborVal # Neighbor's value goes to former blank space
        node.add_child4(Node(newBoard4)) # New board configuration is added as a child node

        if levelNumber4 <= maxLevels: # Checks if bottom level has been reached
          levelNumber4 = levelNumber4 + 1 # child's level value is updated
          node.child4.level = levelNumber4
          buildTree(node.child4, blankPos, levelNumber4) # child4 is added to node


buildTree(root, []) # Tree is constructed with the starting state and empty blank position as input

# Breadth First Search algorithm
# Inputs are current node and the queue
# Breadth First Search searches every node in a level before moving onto next level
# Queue allows for this traversal because first nodes in are the first nodes out
# Nodes of previous level are in the back so with a queue, they get searched first
def breadthFirstSearch(node, queue):
  queue.append(node) # Start node is appended to queue
  while len(queue) > 0: # Loops until the queue is empty
    node = queue.pop(0) # Gets the next node to be processed
    if node.data == goalBoard: # Checks if node's board is same as the goal board
      return node
    else:
      # Nodes of the next level are appended to front of the queue
      if node != None:
        if node.child1 != None:
          queue.append(node.child1)
        if node.child2 != None:
          queue.append(node.child2)
        if node.child3 != None:
          queue.append(node.child3)
        if node.child4 != None:
          queue.append(node.child4)

# Depth First Search algorithm
# Inputs are the current node and the stack
# Depth First Search searches nodes from root to the bottom level before 
# traversing back up and repeating the process with the next branch of nodes
# A stack allows for this traversal because last nodes in are first nodes out
def depthFirstSearch(node, stack):
  stack.append(node) # start node is appended to the stack
  while len(stack) > 0: # Loops until the stack is empty
    node = stack.pop() # Gets the next node to be processed
    if node.data == goalBoard: # Checks if node's board is same as the goal board
      return node
    else:
      # Nodes of the next level are appended to top of the stack
      if node != None:
        if node.child1 != None:
          stack.append(node.child1)
        if node.child2 != None:
          stack.append(node.child2)
        if node.child3 != None:
          stack.append(node.child3)
        if node.child4 != None:
          stack.append(node.child4)

# Uniform Cost Search algorithm
# Input is the current node
# Uniform Cost Search searches nodes based on minimum cost
# Cost = number of moves taken to get to current state
# Heap dictionary is used because it stores priority level of each node
# Lower cost nodes have higher priority and will be processed first
def UniformCostSearch(node):
  hd = heapdict.heapdict() # Heap Dictionary
  hd[node] = 0 # start node is added with a cost/priority of 0
  while len(list(hd)) > 0: # Loops until heap dictionary is empty
    # Pop node off dictionary
    # Popping off heap dictionary gives a tuple, so two values are used to store it
    # Only need the node portion
    # Variable l exists only to seperate the tuple and is no longer needed
    node, l = hd.popitem() 
    if node.data == goalBoard: # Checks if node's board is same as the goal board
      return node
    else:
      # Nodes of the next level are added to heap dictionary
      # node's level = number of moves taken so far = cost = priority
      # Therefore, level value from node is the node's priority
      if node != None:
        if node.child1 != None:
          hd[node.child1] = node.child1.level
        if node.child2 != None:
          hd[node.child2] = node.child2.level
        if node.child3 != None:
          hd[node.child3] = node.child3.level
        if node.child4 != None:
          hd[node.child4] = node.child4.level

# Prints the start state, intermediate states, and goal state for each algorithm
def printStates(node):
  print("Number of moves taken: ", node.level) # Number of moves taken to reach goal state
  nodeStack = [] # Stack to hold nodes

  # Traverses through the node's ancestors till root is reached
  # Nodes are stored in nodeStack
  while node != None:
    nodeStack.append(node)
    node = node.parent

  # Loops until nodeStack is empty
  # Prints out every state in the path from start(Top) to finish(Bottom)
  while len(nodeStack) > 0:
    node = nodeStack.pop()
    print(node.data[0])
    print(node.data[1])
    print(node.data[2])
    print(" ")

# Prints Breadth First Search Path
print(" ")
print("BREADTH FIRST SEARCH")
print("--------------------")
print(" ")
bfsGoalNode = breadthFirstSearch(root, []) # Final node in BFS path
if bfsGoalNode != None:
  printStates(bfsGoalNode) # Print BFS path
else:
  print("Goal state not found in 16 moves or less")

# Prints Depth First Search Path
print(" ")
print("DEPTH FIRST SEARCH")
print("--------------------")
print(" ")
dfsGoalNode = depthFirstSearch(root, []) # Final node in DFS path
if dfsGoalNode != None:
  printStates(dfsGoalNode) # Print DFS path
else:
  print("Goal state not found in 16 moves or less")

# Prints Uniform Cost Search Path
print(" ")
print("UNIFORM COST SEARCH")
print("--------------------")
print(" ")
ucsGoalNode = UniformCostSearch(root) # Final node in UCS path
if ucsGoalNode != None:
  printStates(ucsGoalNode) # Print UCS path
else:
  print("Goal state not found in 16 moves or less")